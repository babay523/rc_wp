## AI 使用说明与决策记录

### 1. AI 在哪些关键地方提供了帮助

- **需求澄清与系统边界梳理**  
  - 将“统一通知系统”拆解为：统一入口 API、异步任务持久化、消息队列投递、外部 HTTP 调用、重试与退避、状态查询、日志与监控等核心能力。  
  - 明确区分了“本系统要解决的问题”和“本系统 V1 不解决的问题”（例如复杂业务编排、Exactly-Once、业务含义处理），帮助快速锁定 V1 版本的边界。

- **系统架构与时序设计**  
  - 设计了整体架构图：内部业务系统 → 通知系统（API 接入层 + MQ + Dispatcher + DB + 日志） → 外部供应商 API。  
  - 设计了通知系统内部架构图：`NotificationAPI`、`TaskRepo`、`VendorConfig`、`MQProducer/MQConsumer`、`Dispatcher`、`RetryPolicy`、`HttpClient`、`LogSys` 等模块。  
  - 给出了从业务系统发起请求到外部 API 调用完成的时序图（包含失败、重试、死信、日志记录等关键步骤）。

- **核心设计与方案取舍**  
  - 明确提出并论证采用 **“至少一次投递（At-Least-Once）+ 业务幂等”** 的可靠性语义，而非 Exactly-Once 或分布式事务。  
  - 说明了为何使用“异步 + 消息队列 + 数据库持久化”的模式来解耦业务系统与外部供应商，避免同步调用带来的耦合与风险。  
  - 提供了失败重试策略（指数退避）和死信/失败任务处理思路。

- **详细文档与 README 结构化编写**  
  - 帮助补充撰写 `readme.md`，系统性整理了：核心设计说明、API 设计、表结构草案、消息结构、演进建议。  

- **功能清单与检查**  
  - 对列出的功能点（REST 接入、异步持久化、RocketMQ 集成、重试策略、幂等、监控、数据保留等）逐条对照当前设计，给出“已覆盖 / 需补充”的判断，帮助你确认设计完整性。

---

### 2. AI 给出过哪些你没有完全采纳的建议

- **技术栈选择上的灵活性建议**  
  - AI 初始方案建议使用 Java/Spring Boot + MQ，但也给出了 Node.js/Go 等其他语言的可选方向。  
  - 最终选择 Java/Spring Boot + RocketMQ 的组合，没有展开其他语言和 MQ 产品的比较与实现细节。

- **平台级高级能力的提前实现**  
  - AI 提出过后续可以演进到：统一限流/熔断平台、多租户隔离、动态路由中心、灰度发布、可视化控制台等。  
  - 在当前版本中**没有采纳这些“过度设计”**，而是将其明确标注为未来演进方向，V1 不实现。

- **可视化控制台与完整监控大盘**  
  - AI 建议未来引入前端控制台（任务查询、失败重放等）和完整监控大盘（Prometheus + Grafana、ELK）。  
  - 当前版本文档中只保留了“日志与监控数据输出、预留监控指标”的设计，并未采纳“立即建设前端控制台和复杂大盘”的建议。

- **更复杂的供应商模板与脚本化映射**  
  - AI 说明了可以通过模板/DSL 脚本来做字段映射、复杂数据转换。  
  - 在需求中更强调“业务系统自己控制数据格式”，V1 中仅保留了简单的 `vendor_config`，没有采用复杂模板/脚本机制。

---

### 3. 哪些关键决策是你自己做出的，以及原因

- **明确 V1 的系统边界与“只做核心、不做周边”**  
  - 确认：V1 仅专注于“把单条通知可靠送达”，不做工作流编排、不做复杂路由、不做业务含义处理。  
  - 原因：避免一开始把系统做成“过度庞大平台”，确保可以快速交付、易于理解和运维。

- **不采用复杂的分布式事务/Exactly-Once 方案**  
  - 虽然 AI 介绍了更严格的一致性方案可能性，但最终选择“至少一次投递 + 外部幂等”的路线。  
  - 原因：综合考虑实现成本、系统复杂度与业务场景实际需求，认为重复通知可由业务去重，而“丢失通知”才是更大的风险。

- **将部分平台能力定位为演进方向，而非 V1 必做**  
  - 对于限流、熔断、多租户隔离、动态路由、灰度发布、工作流引擎等，最终决定：  
    - 当前仅在文档中作为“未来演进方向”记录；  
    - 不纳入本次交付范围。  
  - 原因：更需要一个简单可靠、易推广的第一版。

- **简化供应商侧的抽象程度**  
  - AI 提出可以设计较为通用、可配置的 vendor 模板与脚本映射能力；  
  - 主导决策：V1 中主要通过 `vendorCode + targetUrl + headers + body` 的方式完成，数据转换能力保持在最低限度，由业务系统自己负责处理复杂映射。  
  - 原因：减少系统内部“黑盒转换”的复杂度，让业务方对最终请求格式有更强掌控感。

- **对文档风格和内容颗粒度的把控**  
  - 多次要求对 README 中“系统职责、不职责、架构图、核心设计”等内容进行重新整理与结构化。  
  - 原因：希望文档能让非技术同学（或初学者）也较容易理解系统做什么、不做什么；并且便于后续团队在此基础上扩展实现。

---


